# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from lcm_to_ros/quadruped_menu_data_lcmt.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class quadruped_menu_data_lcmt(genpy.Message):
  _md5sum = "9ab9aae0547b79b2b0e50af1fdc2a2dc"
  _type = "lcm_to_ros/quadruped_menu_data_lcmt"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#######################################################################
# This message was automatically generated by the lcm_to_ros package
# https://github.com/nrjl/lcm_to_ros, nicholas.lawrance@oregonstate.edu
#######################################################################
#
# Source message:    .msg
# Creation:          Fri Apr 16 18:27:01 2021
#
#######################################################################
bool                cheater_mode
int64               control_mode
                    
bool                use_wbc
bool                use_rc
                    
bool                display_heightmap
bool                display_path_planning
bool                display_potential_field
bool                display_traverability
                    
float64[3]          Kd_body
float64[3]          Kd_cam
float64[3]          Kd_clm
float64[3]          Kd_foot
float64[3]          Kd_joint
float64[3]          Kd_ori
float64[3]          Kp_body
float64[3]          Kp_cam
float64[3]          Kp_clm
float64[3]          Kp_foot
float64[3]          Kp_joint
float64[3]          Kp_ori
float64[3]          Q_ang
float64[3]          Q_ori
float64[3]          Q_pos
float64[3]          Q_vel
float64[3]          RPC_H_phi0
float64[3]          RPC_H_r_rot
float64[3]          RPC_H_r_trans
float64[3]          RPC_H_theta0
float64[3]          RPC_Q_dp
float64[3]          RPC_Q_dtheta
float64[3]          RPC_Q_p
float64[3]          RPC_Q_theta
float64[3]          RPC_R_f
float64[3]          RPC_R_r
float64[3]          RPC_filter
float64[3]          RPC_gravity
float64[3]          RPC_inertia
float64             RPC_interface_type
float64             RPC_mass
float64             RPC_mu
float64             RPC_use_async_filt
float64             RPC_use_pred_comp
float64             RPC_visualize_pred
float64             R_control
float64             R_prev
float64[3]          Swing_Kd_cartesian
float64[3]          Swing_Kd_joint
float64[3]          Swing_Kp_cartesian
float64[3]          Swing_Kp_joint
float64[3]          Swing_step_offset
float64             Swing_traj_height
float64             Swing_use_tau_ff
float64             acro_task
float64[3]          des_dp
float64[3]          des_dp_max
float64[3]          des_dtheta
float64[3]          des_dtheta_max
float64[3]          des_p
float64[3]          des_theta
float64[3]          des_theta_max
float64[3]          gait_disturbance
float64             gait_max_leg_angle
float64             gait_max_stance_time
float64             gait_min_stance_time
float64             gait_override
float64             gait_period_time
float64[3]          gait_recovery
float64             gait_switching_phase
float64             gait_type
float64             stance_legs
"""
  __slots__ = ['cheater_mode','control_mode','use_wbc','use_rc','display_heightmap','display_path_planning','display_potential_field','display_traverability','Kd_body','Kd_cam','Kd_clm','Kd_foot','Kd_joint','Kd_ori','Kp_body','Kp_cam','Kp_clm','Kp_foot','Kp_joint','Kp_ori','Q_ang','Q_ori','Q_pos','Q_vel','RPC_H_phi0','RPC_H_r_rot','RPC_H_r_trans','RPC_H_theta0','RPC_Q_dp','RPC_Q_dtheta','RPC_Q_p','RPC_Q_theta','RPC_R_f','RPC_R_r','RPC_filter','RPC_gravity','RPC_inertia','RPC_interface_type','RPC_mass','RPC_mu','RPC_use_async_filt','RPC_use_pred_comp','RPC_visualize_pred','R_control','R_prev','Swing_Kd_cartesian','Swing_Kd_joint','Swing_Kp_cartesian','Swing_Kp_joint','Swing_step_offset','Swing_traj_height','Swing_use_tau_ff','acro_task','des_dp','des_dp_max','des_dtheta','des_dtheta_max','des_p','des_theta','des_theta_max','gait_disturbance','gait_max_leg_angle','gait_max_stance_time','gait_min_stance_time','gait_override','gait_period_time','gait_recovery','gait_switching_phase','gait_type','stance_legs']
  _slot_types = ['bool','int64','bool','bool','bool','bool','bool','bool','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64','float64','float64','float64','float64','float64','float64','float64','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64','float64','float64','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64[3]','float64','float64','float64','float64','float64','float64[3]','float64','float64','float64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       cheater_mode,control_mode,use_wbc,use_rc,display_heightmap,display_path_planning,display_potential_field,display_traverability,Kd_body,Kd_cam,Kd_clm,Kd_foot,Kd_joint,Kd_ori,Kp_body,Kp_cam,Kp_clm,Kp_foot,Kp_joint,Kp_ori,Q_ang,Q_ori,Q_pos,Q_vel,RPC_H_phi0,RPC_H_r_rot,RPC_H_r_trans,RPC_H_theta0,RPC_Q_dp,RPC_Q_dtheta,RPC_Q_p,RPC_Q_theta,RPC_R_f,RPC_R_r,RPC_filter,RPC_gravity,RPC_inertia,RPC_interface_type,RPC_mass,RPC_mu,RPC_use_async_filt,RPC_use_pred_comp,RPC_visualize_pred,R_control,R_prev,Swing_Kd_cartesian,Swing_Kd_joint,Swing_Kp_cartesian,Swing_Kp_joint,Swing_step_offset,Swing_traj_height,Swing_use_tau_ff,acro_task,des_dp,des_dp_max,des_dtheta,des_dtheta_max,des_p,des_theta,des_theta_max,gait_disturbance,gait_max_leg_angle,gait_max_stance_time,gait_min_stance_time,gait_override,gait_period_time,gait_recovery,gait_switching_phase,gait_type,stance_legs

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(quadruped_menu_data_lcmt, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.cheater_mode is None:
        self.cheater_mode = False
      if self.control_mode is None:
        self.control_mode = 0
      if self.use_wbc is None:
        self.use_wbc = False
      if self.use_rc is None:
        self.use_rc = False
      if self.display_heightmap is None:
        self.display_heightmap = False
      if self.display_path_planning is None:
        self.display_path_planning = False
      if self.display_potential_field is None:
        self.display_potential_field = False
      if self.display_traverability is None:
        self.display_traverability = False
      if self.Kd_body is None:
        self.Kd_body = [0.] * 3
      if self.Kd_cam is None:
        self.Kd_cam = [0.] * 3
      if self.Kd_clm is None:
        self.Kd_clm = [0.] * 3
      if self.Kd_foot is None:
        self.Kd_foot = [0.] * 3
      if self.Kd_joint is None:
        self.Kd_joint = [0.] * 3
      if self.Kd_ori is None:
        self.Kd_ori = [0.] * 3
      if self.Kp_body is None:
        self.Kp_body = [0.] * 3
      if self.Kp_cam is None:
        self.Kp_cam = [0.] * 3
      if self.Kp_clm is None:
        self.Kp_clm = [0.] * 3
      if self.Kp_foot is None:
        self.Kp_foot = [0.] * 3
      if self.Kp_joint is None:
        self.Kp_joint = [0.] * 3
      if self.Kp_ori is None:
        self.Kp_ori = [0.] * 3
      if self.Q_ang is None:
        self.Q_ang = [0.] * 3
      if self.Q_ori is None:
        self.Q_ori = [0.] * 3
      if self.Q_pos is None:
        self.Q_pos = [0.] * 3
      if self.Q_vel is None:
        self.Q_vel = [0.] * 3
      if self.RPC_H_phi0 is None:
        self.RPC_H_phi0 = [0.] * 3
      if self.RPC_H_r_rot is None:
        self.RPC_H_r_rot = [0.] * 3
      if self.RPC_H_r_trans is None:
        self.RPC_H_r_trans = [0.] * 3
      if self.RPC_H_theta0 is None:
        self.RPC_H_theta0 = [0.] * 3
      if self.RPC_Q_dp is None:
        self.RPC_Q_dp = [0.] * 3
      if self.RPC_Q_dtheta is None:
        self.RPC_Q_dtheta = [0.] * 3
      if self.RPC_Q_p is None:
        self.RPC_Q_p = [0.] * 3
      if self.RPC_Q_theta is None:
        self.RPC_Q_theta = [0.] * 3
      if self.RPC_R_f is None:
        self.RPC_R_f = [0.] * 3
      if self.RPC_R_r is None:
        self.RPC_R_r = [0.] * 3
      if self.RPC_filter is None:
        self.RPC_filter = [0.] * 3
      if self.RPC_gravity is None:
        self.RPC_gravity = [0.] * 3
      if self.RPC_inertia is None:
        self.RPC_inertia = [0.] * 3
      if self.RPC_interface_type is None:
        self.RPC_interface_type = 0.
      if self.RPC_mass is None:
        self.RPC_mass = 0.
      if self.RPC_mu is None:
        self.RPC_mu = 0.
      if self.RPC_use_async_filt is None:
        self.RPC_use_async_filt = 0.
      if self.RPC_use_pred_comp is None:
        self.RPC_use_pred_comp = 0.
      if self.RPC_visualize_pred is None:
        self.RPC_visualize_pred = 0.
      if self.R_control is None:
        self.R_control = 0.
      if self.R_prev is None:
        self.R_prev = 0.
      if self.Swing_Kd_cartesian is None:
        self.Swing_Kd_cartesian = [0.] * 3
      if self.Swing_Kd_joint is None:
        self.Swing_Kd_joint = [0.] * 3
      if self.Swing_Kp_cartesian is None:
        self.Swing_Kp_cartesian = [0.] * 3
      if self.Swing_Kp_joint is None:
        self.Swing_Kp_joint = [0.] * 3
      if self.Swing_step_offset is None:
        self.Swing_step_offset = [0.] * 3
      if self.Swing_traj_height is None:
        self.Swing_traj_height = 0.
      if self.Swing_use_tau_ff is None:
        self.Swing_use_tau_ff = 0.
      if self.acro_task is None:
        self.acro_task = 0.
      if self.des_dp is None:
        self.des_dp = [0.] * 3
      if self.des_dp_max is None:
        self.des_dp_max = [0.] * 3
      if self.des_dtheta is None:
        self.des_dtheta = [0.] * 3
      if self.des_dtheta_max is None:
        self.des_dtheta_max = [0.] * 3
      if self.des_p is None:
        self.des_p = [0.] * 3
      if self.des_theta is None:
        self.des_theta = [0.] * 3
      if self.des_theta_max is None:
        self.des_theta_max = [0.] * 3
      if self.gait_disturbance is None:
        self.gait_disturbance = [0.] * 3
      if self.gait_max_leg_angle is None:
        self.gait_max_leg_angle = 0.
      if self.gait_max_stance_time is None:
        self.gait_max_stance_time = 0.
      if self.gait_min_stance_time is None:
        self.gait_min_stance_time = 0.
      if self.gait_override is None:
        self.gait_override = 0.
      if self.gait_period_time is None:
        self.gait_period_time = 0.
      if self.gait_recovery is None:
        self.gait_recovery = [0.] * 3
      if self.gait_switching_phase is None:
        self.gait_switching_phase = 0.
      if self.gait_type is None:
        self.gait_type = 0.
      if self.stance_legs is None:
        self.stance_legs = 0.
    else:
      self.cheater_mode = False
      self.control_mode = 0
      self.use_wbc = False
      self.use_rc = False
      self.display_heightmap = False
      self.display_path_planning = False
      self.display_potential_field = False
      self.display_traverability = False
      self.Kd_body = [0.] * 3
      self.Kd_cam = [0.] * 3
      self.Kd_clm = [0.] * 3
      self.Kd_foot = [0.] * 3
      self.Kd_joint = [0.] * 3
      self.Kd_ori = [0.] * 3
      self.Kp_body = [0.] * 3
      self.Kp_cam = [0.] * 3
      self.Kp_clm = [0.] * 3
      self.Kp_foot = [0.] * 3
      self.Kp_joint = [0.] * 3
      self.Kp_ori = [0.] * 3
      self.Q_ang = [0.] * 3
      self.Q_ori = [0.] * 3
      self.Q_pos = [0.] * 3
      self.Q_vel = [0.] * 3
      self.RPC_H_phi0 = [0.] * 3
      self.RPC_H_r_rot = [0.] * 3
      self.RPC_H_r_trans = [0.] * 3
      self.RPC_H_theta0 = [0.] * 3
      self.RPC_Q_dp = [0.] * 3
      self.RPC_Q_dtheta = [0.] * 3
      self.RPC_Q_p = [0.] * 3
      self.RPC_Q_theta = [0.] * 3
      self.RPC_R_f = [0.] * 3
      self.RPC_R_r = [0.] * 3
      self.RPC_filter = [0.] * 3
      self.RPC_gravity = [0.] * 3
      self.RPC_inertia = [0.] * 3
      self.RPC_interface_type = 0.
      self.RPC_mass = 0.
      self.RPC_mu = 0.
      self.RPC_use_async_filt = 0.
      self.RPC_use_pred_comp = 0.
      self.RPC_visualize_pred = 0.
      self.R_control = 0.
      self.R_prev = 0.
      self.Swing_Kd_cartesian = [0.] * 3
      self.Swing_Kd_joint = [0.] * 3
      self.Swing_Kp_cartesian = [0.] * 3
      self.Swing_Kp_joint = [0.] * 3
      self.Swing_step_offset = [0.] * 3
      self.Swing_traj_height = 0.
      self.Swing_use_tau_ff = 0.
      self.acro_task = 0.
      self.des_dp = [0.] * 3
      self.des_dp_max = [0.] * 3
      self.des_dtheta = [0.] * 3
      self.des_dtheta_max = [0.] * 3
      self.des_p = [0.] * 3
      self.des_theta = [0.] * 3
      self.des_theta_max = [0.] * 3
      self.gait_disturbance = [0.] * 3
      self.gait_max_leg_angle = 0.
      self.gait_max_stance_time = 0.
      self.gait_min_stance_time = 0.
      self.gait_override = 0.
      self.gait_period_time = 0.
      self.gait_recovery = [0.] * 3
      self.gait_switching_phase = 0.
      self.gait_type = 0.
      self.stance_legs = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_Bq6B().pack(_x.cheater_mode, _x.control_mode, _x.use_wbc, _x.use_rc, _x.display_heightmap, _x.display_path_planning, _x.display_potential_field, _x.display_traverability))
      buff.write(_get_struct_3d().pack(*self.Kd_body))
      buff.write(_get_struct_3d().pack(*self.Kd_cam))
      buff.write(_get_struct_3d().pack(*self.Kd_clm))
      buff.write(_get_struct_3d().pack(*self.Kd_foot))
      buff.write(_get_struct_3d().pack(*self.Kd_joint))
      buff.write(_get_struct_3d().pack(*self.Kd_ori))
      buff.write(_get_struct_3d().pack(*self.Kp_body))
      buff.write(_get_struct_3d().pack(*self.Kp_cam))
      buff.write(_get_struct_3d().pack(*self.Kp_clm))
      buff.write(_get_struct_3d().pack(*self.Kp_foot))
      buff.write(_get_struct_3d().pack(*self.Kp_joint))
      buff.write(_get_struct_3d().pack(*self.Kp_ori))
      buff.write(_get_struct_3d().pack(*self.Q_ang))
      buff.write(_get_struct_3d().pack(*self.Q_ori))
      buff.write(_get_struct_3d().pack(*self.Q_pos))
      buff.write(_get_struct_3d().pack(*self.Q_vel))
      buff.write(_get_struct_3d().pack(*self.RPC_H_phi0))
      buff.write(_get_struct_3d().pack(*self.RPC_H_r_rot))
      buff.write(_get_struct_3d().pack(*self.RPC_H_r_trans))
      buff.write(_get_struct_3d().pack(*self.RPC_H_theta0))
      buff.write(_get_struct_3d().pack(*self.RPC_Q_dp))
      buff.write(_get_struct_3d().pack(*self.RPC_Q_dtheta))
      buff.write(_get_struct_3d().pack(*self.RPC_Q_p))
      buff.write(_get_struct_3d().pack(*self.RPC_Q_theta))
      buff.write(_get_struct_3d().pack(*self.RPC_R_f))
      buff.write(_get_struct_3d().pack(*self.RPC_R_r))
      buff.write(_get_struct_3d().pack(*self.RPC_filter))
      buff.write(_get_struct_3d().pack(*self.RPC_gravity))
      buff.write(_get_struct_3d().pack(*self.RPC_inertia))
      _x = self
      buff.write(_get_struct_8d().pack(_x.RPC_interface_type, _x.RPC_mass, _x.RPC_mu, _x.RPC_use_async_filt, _x.RPC_use_pred_comp, _x.RPC_visualize_pred, _x.R_control, _x.R_prev))
      buff.write(_get_struct_3d().pack(*self.Swing_Kd_cartesian))
      buff.write(_get_struct_3d().pack(*self.Swing_Kd_joint))
      buff.write(_get_struct_3d().pack(*self.Swing_Kp_cartesian))
      buff.write(_get_struct_3d().pack(*self.Swing_Kp_joint))
      buff.write(_get_struct_3d().pack(*self.Swing_step_offset))
      _x = self
      buff.write(_get_struct_3d().pack(_x.Swing_traj_height, _x.Swing_use_tau_ff, _x.acro_task))
      buff.write(_get_struct_3d().pack(*self.des_dp))
      buff.write(_get_struct_3d().pack(*self.des_dp_max))
      buff.write(_get_struct_3d().pack(*self.des_dtheta))
      buff.write(_get_struct_3d().pack(*self.des_dtheta_max))
      buff.write(_get_struct_3d().pack(*self.des_p))
      buff.write(_get_struct_3d().pack(*self.des_theta))
      buff.write(_get_struct_3d().pack(*self.des_theta_max))
      buff.write(_get_struct_3d().pack(*self.gait_disturbance))
      _x = self
      buff.write(_get_struct_5d().pack(_x.gait_max_leg_angle, _x.gait_max_stance_time, _x.gait_min_stance_time, _x.gait_override, _x.gait_period_time))
      buff.write(_get_struct_3d().pack(*self.gait_recovery))
      _x = self
      buff.write(_get_struct_3d().pack(_x.gait_switching_phase, _x.gait_type, _x.stance_legs))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 15
      (_x.cheater_mode, _x.control_mode, _x.use_wbc, _x.use_rc, _x.display_heightmap, _x.display_path_planning, _x.display_potential_field, _x.display_traverability,) = _get_struct_Bq6B().unpack(str[start:end])
      self.cheater_mode = bool(self.cheater_mode)
      self.use_wbc = bool(self.use_wbc)
      self.use_rc = bool(self.use_rc)
      self.display_heightmap = bool(self.display_heightmap)
      self.display_path_planning = bool(self.display_path_planning)
      self.display_potential_field = bool(self.display_potential_field)
      self.display_traverability = bool(self.display_traverability)
      start = end
      end += 24
      self.Kd_body = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kd_cam = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kd_clm = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kd_foot = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kd_joint = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kd_ori = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kp_body = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kp_cam = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kp_clm = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kp_foot = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kp_joint = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Kp_ori = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Q_ang = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Q_ori = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Q_pos = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Q_vel = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_H_phi0 = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_H_r_rot = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_H_r_trans = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_H_theta0 = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_Q_dp = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_Q_dtheta = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_Q_p = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_Q_theta = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_R_f = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_R_r = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_filter = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_gravity = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.RPC_inertia = _get_struct_3d().unpack(str[start:end])
      _x = self
      start = end
      end += 64
      (_x.RPC_interface_type, _x.RPC_mass, _x.RPC_mu, _x.RPC_use_async_filt, _x.RPC_use_pred_comp, _x.RPC_visualize_pred, _x.R_control, _x.R_prev,) = _get_struct_8d().unpack(str[start:end])
      start = end
      end += 24
      self.Swing_Kd_cartesian = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Swing_Kd_joint = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Swing_Kp_cartesian = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Swing_Kp_joint = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.Swing_step_offset = _get_struct_3d().unpack(str[start:end])
      _x = self
      start = end
      end += 24
      (_x.Swing_traj_height, _x.Swing_use_tau_ff, _x.acro_task,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_dp = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_dp_max = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_dtheta = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_dtheta_max = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_p = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_theta = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_theta_max = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.gait_disturbance = _get_struct_3d().unpack(str[start:end])
      _x = self
      start = end
      end += 40
      (_x.gait_max_leg_angle, _x.gait_max_stance_time, _x.gait_min_stance_time, _x.gait_override, _x.gait_period_time,) = _get_struct_5d().unpack(str[start:end])
      start = end
      end += 24
      self.gait_recovery = _get_struct_3d().unpack(str[start:end])
      _x = self
      start = end
      end += 24
      (_x.gait_switching_phase, _x.gait_type, _x.stance_legs,) = _get_struct_3d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_Bq6B().pack(_x.cheater_mode, _x.control_mode, _x.use_wbc, _x.use_rc, _x.display_heightmap, _x.display_path_planning, _x.display_potential_field, _x.display_traverability))
      buff.write(self.Kd_body.tostring())
      buff.write(self.Kd_cam.tostring())
      buff.write(self.Kd_clm.tostring())
      buff.write(self.Kd_foot.tostring())
      buff.write(self.Kd_joint.tostring())
      buff.write(self.Kd_ori.tostring())
      buff.write(self.Kp_body.tostring())
      buff.write(self.Kp_cam.tostring())
      buff.write(self.Kp_clm.tostring())
      buff.write(self.Kp_foot.tostring())
      buff.write(self.Kp_joint.tostring())
      buff.write(self.Kp_ori.tostring())
      buff.write(self.Q_ang.tostring())
      buff.write(self.Q_ori.tostring())
      buff.write(self.Q_pos.tostring())
      buff.write(self.Q_vel.tostring())
      buff.write(self.RPC_H_phi0.tostring())
      buff.write(self.RPC_H_r_rot.tostring())
      buff.write(self.RPC_H_r_trans.tostring())
      buff.write(self.RPC_H_theta0.tostring())
      buff.write(self.RPC_Q_dp.tostring())
      buff.write(self.RPC_Q_dtheta.tostring())
      buff.write(self.RPC_Q_p.tostring())
      buff.write(self.RPC_Q_theta.tostring())
      buff.write(self.RPC_R_f.tostring())
      buff.write(self.RPC_R_r.tostring())
      buff.write(self.RPC_filter.tostring())
      buff.write(self.RPC_gravity.tostring())
      buff.write(self.RPC_inertia.tostring())
      _x = self
      buff.write(_get_struct_8d().pack(_x.RPC_interface_type, _x.RPC_mass, _x.RPC_mu, _x.RPC_use_async_filt, _x.RPC_use_pred_comp, _x.RPC_visualize_pred, _x.R_control, _x.R_prev))
      buff.write(self.Swing_Kd_cartesian.tostring())
      buff.write(self.Swing_Kd_joint.tostring())
      buff.write(self.Swing_Kp_cartesian.tostring())
      buff.write(self.Swing_Kp_joint.tostring())
      buff.write(self.Swing_step_offset.tostring())
      _x = self
      buff.write(_get_struct_3d().pack(_x.Swing_traj_height, _x.Swing_use_tau_ff, _x.acro_task))
      buff.write(self.des_dp.tostring())
      buff.write(self.des_dp_max.tostring())
      buff.write(self.des_dtheta.tostring())
      buff.write(self.des_dtheta_max.tostring())
      buff.write(self.des_p.tostring())
      buff.write(self.des_theta.tostring())
      buff.write(self.des_theta_max.tostring())
      buff.write(self.gait_disturbance.tostring())
      _x = self
      buff.write(_get_struct_5d().pack(_x.gait_max_leg_angle, _x.gait_max_stance_time, _x.gait_min_stance_time, _x.gait_override, _x.gait_period_time))
      buff.write(self.gait_recovery.tostring())
      _x = self
      buff.write(_get_struct_3d().pack(_x.gait_switching_phase, _x.gait_type, _x.stance_legs))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 15
      (_x.cheater_mode, _x.control_mode, _x.use_wbc, _x.use_rc, _x.display_heightmap, _x.display_path_planning, _x.display_potential_field, _x.display_traverability,) = _get_struct_Bq6B().unpack(str[start:end])
      self.cheater_mode = bool(self.cheater_mode)
      self.use_wbc = bool(self.use_wbc)
      self.use_rc = bool(self.use_rc)
      self.display_heightmap = bool(self.display_heightmap)
      self.display_path_planning = bool(self.display_path_planning)
      self.display_potential_field = bool(self.display_potential_field)
      self.display_traverability = bool(self.display_traverability)
      start = end
      end += 24
      self.Kd_body = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kd_cam = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kd_clm = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kd_foot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kd_joint = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kd_ori = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kp_body = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kp_cam = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kp_clm = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kp_foot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kp_joint = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Kp_ori = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Q_ang = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Q_ori = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Q_pos = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Q_vel = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_H_phi0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_H_r_rot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_H_r_trans = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_H_theta0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_Q_dp = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_Q_dtheta = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_Q_p = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_Q_theta = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_R_f = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_R_r = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_filter = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_gravity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.RPC_inertia = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      _x = self
      start = end
      end += 64
      (_x.RPC_interface_type, _x.RPC_mass, _x.RPC_mu, _x.RPC_use_async_filt, _x.RPC_use_pred_comp, _x.RPC_visualize_pred, _x.R_control, _x.R_prev,) = _get_struct_8d().unpack(str[start:end])
      start = end
      end += 24
      self.Swing_Kd_cartesian = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Swing_Kd_joint = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Swing_Kp_cartesian = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Swing_Kp_joint = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.Swing_step_offset = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      _x = self
      start = end
      end += 24
      (_x.Swing_traj_height, _x.Swing_use_tau_ff, _x.acro_task,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.des_dp = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.des_dp_max = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.des_dtheta = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.des_dtheta_max = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.des_p = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.des_theta = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.des_theta_max = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.gait_disturbance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      _x = self
      start = end
      end += 40
      (_x.gait_max_leg_angle, _x.gait_max_stance_time, _x.gait_min_stance_time, _x.gait_override, _x.gait_period_time,) = _get_struct_5d().unpack(str[start:end])
      start = end
      end += 24
      self.gait_recovery = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      _x = self
      start = end
      end += 24
      (_x.gait_switching_phase, _x.gait_type, _x.stance_legs,) = _get_struct_3d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_5d = None
def _get_struct_5d():
    global _struct_5d
    if _struct_5d is None:
        _struct_5d = struct.Struct("<5d")
    return _struct_5d
_struct_8d = None
def _get_struct_8d():
    global _struct_8d
    if _struct_8d is None:
        _struct_8d = struct.Struct("<8d")
    return _struct_8d
_struct_Bq6B = None
def _get_struct_Bq6B():
    global _struct_Bq6B
    if _struct_Bq6B is None:
        _struct_Bq6B = struct.Struct("<Bq6B")
    return _struct_Bq6B
