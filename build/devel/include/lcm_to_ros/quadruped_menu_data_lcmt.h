// Generated by gencpp from file lcm_to_ros/quadruped_menu_data_lcmt.msg
// DO NOT EDIT!


#ifndef LCM_TO_ROS_MESSAGE_QUADRUPED_MENU_DATA_LCMT_H
#define LCM_TO_ROS_MESSAGE_QUADRUPED_MENU_DATA_LCMT_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace lcm_to_ros
{
template <class ContainerAllocator>
struct quadruped_menu_data_lcmt_
{
  typedef quadruped_menu_data_lcmt_<ContainerAllocator> Type;

  quadruped_menu_data_lcmt_()
    : cheater_mode(false)
    , control_mode(0)
    , use_wbc(false)
    , use_rc(false)
    , display_heightmap(false)
    , display_path_planning(false)
    , display_potential_field(false)
    , display_traverability(false)
    , Kd_body()
    , Kd_cam()
    , Kd_clm()
    , Kd_foot()
    , Kd_joint()
    , Kd_ori()
    , Kp_body()
    , Kp_cam()
    , Kp_clm()
    , Kp_foot()
    , Kp_joint()
    , Kp_ori()
    , Q_ang()
    , Q_ori()
    , Q_pos()
    , Q_vel()
    , RPC_H_phi0()
    , RPC_H_r_rot()
    , RPC_H_r_trans()
    , RPC_H_theta0()
    , RPC_Q_dp()
    , RPC_Q_dtheta()
    , RPC_Q_p()
    , RPC_Q_theta()
    , RPC_R_f()
    , RPC_R_r()
    , RPC_filter()
    , RPC_gravity()
    , RPC_inertia()
    , RPC_interface_type(0.0)
    , RPC_mass(0.0)
    , RPC_mu(0.0)
    , RPC_use_async_filt(0.0)
    , RPC_use_pred_comp(0.0)
    , RPC_visualize_pred(0.0)
    , R_control(0.0)
    , R_prev(0.0)
    , Swing_Kd_cartesian()
    , Swing_Kd_joint()
    , Swing_Kp_cartesian()
    , Swing_Kp_joint()
    , Swing_step_offset()
    , Swing_traj_height(0.0)
    , Swing_use_tau_ff(0.0)
    , acro_task(0.0)
    , des_dp()
    , des_dp_max()
    , des_dtheta()
    , des_dtheta_max()
    , des_p()
    , des_theta()
    , des_theta_max()
    , gait_disturbance()
    , gait_max_leg_angle(0.0)
    , gait_max_stance_time(0.0)
    , gait_min_stance_time(0.0)
    , gait_override(0.0)
    , gait_period_time(0.0)
    , gait_recovery()
    , gait_switching_phase(0.0)
    , gait_type(0.0)
    , stance_legs(0.0)  {
      Kd_body.assign(0.0);

      Kd_cam.assign(0.0);

      Kd_clm.assign(0.0);

      Kd_foot.assign(0.0);

      Kd_joint.assign(0.0);

      Kd_ori.assign(0.0);

      Kp_body.assign(0.0);

      Kp_cam.assign(0.0);

      Kp_clm.assign(0.0);

      Kp_foot.assign(0.0);

      Kp_joint.assign(0.0);

      Kp_ori.assign(0.0);

      Q_ang.assign(0.0);

      Q_ori.assign(0.0);

      Q_pos.assign(0.0);

      Q_vel.assign(0.0);

      RPC_H_phi0.assign(0.0);

      RPC_H_r_rot.assign(0.0);

      RPC_H_r_trans.assign(0.0);

      RPC_H_theta0.assign(0.0);

      RPC_Q_dp.assign(0.0);

      RPC_Q_dtheta.assign(0.0);

      RPC_Q_p.assign(0.0);

      RPC_Q_theta.assign(0.0);

      RPC_R_f.assign(0.0);

      RPC_R_r.assign(0.0);

      RPC_filter.assign(0.0);

      RPC_gravity.assign(0.0);

      RPC_inertia.assign(0.0);

      Swing_Kd_cartesian.assign(0.0);

      Swing_Kd_joint.assign(0.0);

      Swing_Kp_cartesian.assign(0.0);

      Swing_Kp_joint.assign(0.0);

      Swing_step_offset.assign(0.0);

      des_dp.assign(0.0);

      des_dp_max.assign(0.0);

      des_dtheta.assign(0.0);

      des_dtheta_max.assign(0.0);

      des_p.assign(0.0);

      des_theta.assign(0.0);

      des_theta_max.assign(0.0);

      gait_disturbance.assign(0.0);

      gait_recovery.assign(0.0);
  }
  quadruped_menu_data_lcmt_(const ContainerAllocator& _alloc)
    : cheater_mode(false)
    , control_mode(0)
    , use_wbc(false)
    , use_rc(false)
    , display_heightmap(false)
    , display_path_planning(false)
    , display_potential_field(false)
    , display_traverability(false)
    , Kd_body()
    , Kd_cam()
    , Kd_clm()
    , Kd_foot()
    , Kd_joint()
    , Kd_ori()
    , Kp_body()
    , Kp_cam()
    , Kp_clm()
    , Kp_foot()
    , Kp_joint()
    , Kp_ori()
    , Q_ang()
    , Q_ori()
    , Q_pos()
    , Q_vel()
    , RPC_H_phi0()
    , RPC_H_r_rot()
    , RPC_H_r_trans()
    , RPC_H_theta0()
    , RPC_Q_dp()
    , RPC_Q_dtheta()
    , RPC_Q_p()
    , RPC_Q_theta()
    , RPC_R_f()
    , RPC_R_r()
    , RPC_filter()
    , RPC_gravity()
    , RPC_inertia()
    , RPC_interface_type(0.0)
    , RPC_mass(0.0)
    , RPC_mu(0.0)
    , RPC_use_async_filt(0.0)
    , RPC_use_pred_comp(0.0)
    , RPC_visualize_pred(0.0)
    , R_control(0.0)
    , R_prev(0.0)
    , Swing_Kd_cartesian()
    , Swing_Kd_joint()
    , Swing_Kp_cartesian()
    , Swing_Kp_joint()
    , Swing_step_offset()
    , Swing_traj_height(0.0)
    , Swing_use_tau_ff(0.0)
    , acro_task(0.0)
    , des_dp()
    , des_dp_max()
    , des_dtheta()
    , des_dtheta_max()
    , des_p()
    , des_theta()
    , des_theta_max()
    , gait_disturbance()
    , gait_max_leg_angle(0.0)
    , gait_max_stance_time(0.0)
    , gait_min_stance_time(0.0)
    , gait_override(0.0)
    , gait_period_time(0.0)
    , gait_recovery()
    , gait_switching_phase(0.0)
    , gait_type(0.0)
    , stance_legs(0.0)  {
  (void)_alloc;
      Kd_body.assign(0.0);

      Kd_cam.assign(0.0);

      Kd_clm.assign(0.0);

      Kd_foot.assign(0.0);

      Kd_joint.assign(0.0);

      Kd_ori.assign(0.0);

      Kp_body.assign(0.0);

      Kp_cam.assign(0.0);

      Kp_clm.assign(0.0);

      Kp_foot.assign(0.0);

      Kp_joint.assign(0.0);

      Kp_ori.assign(0.0);

      Q_ang.assign(0.0);

      Q_ori.assign(0.0);

      Q_pos.assign(0.0);

      Q_vel.assign(0.0);

      RPC_H_phi0.assign(0.0);

      RPC_H_r_rot.assign(0.0);

      RPC_H_r_trans.assign(0.0);

      RPC_H_theta0.assign(0.0);

      RPC_Q_dp.assign(0.0);

      RPC_Q_dtheta.assign(0.0);

      RPC_Q_p.assign(0.0);

      RPC_Q_theta.assign(0.0);

      RPC_R_f.assign(0.0);

      RPC_R_r.assign(0.0);

      RPC_filter.assign(0.0);

      RPC_gravity.assign(0.0);

      RPC_inertia.assign(0.0);

      Swing_Kd_cartesian.assign(0.0);

      Swing_Kd_joint.assign(0.0);

      Swing_Kp_cartesian.assign(0.0);

      Swing_Kp_joint.assign(0.0);

      Swing_step_offset.assign(0.0);

      des_dp.assign(0.0);

      des_dp_max.assign(0.0);

      des_dtheta.assign(0.0);

      des_dtheta_max.assign(0.0);

      des_p.assign(0.0);

      des_theta.assign(0.0);

      des_theta_max.assign(0.0);

      gait_disturbance.assign(0.0);

      gait_recovery.assign(0.0);
  }



   typedef uint8_t _cheater_mode_type;
  _cheater_mode_type cheater_mode;

   typedef int64_t _control_mode_type;
  _control_mode_type control_mode;

   typedef uint8_t _use_wbc_type;
  _use_wbc_type use_wbc;

   typedef uint8_t _use_rc_type;
  _use_rc_type use_rc;

   typedef uint8_t _display_heightmap_type;
  _display_heightmap_type display_heightmap;

   typedef uint8_t _display_path_planning_type;
  _display_path_planning_type display_path_planning;

   typedef uint8_t _display_potential_field_type;
  _display_potential_field_type display_potential_field;

   typedef uint8_t _display_traverability_type;
  _display_traverability_type display_traverability;

   typedef boost::array<double, 3>  _Kd_body_type;
  _Kd_body_type Kd_body;

   typedef boost::array<double, 3>  _Kd_cam_type;
  _Kd_cam_type Kd_cam;

   typedef boost::array<double, 3>  _Kd_clm_type;
  _Kd_clm_type Kd_clm;

   typedef boost::array<double, 3>  _Kd_foot_type;
  _Kd_foot_type Kd_foot;

   typedef boost::array<double, 3>  _Kd_joint_type;
  _Kd_joint_type Kd_joint;

   typedef boost::array<double, 3>  _Kd_ori_type;
  _Kd_ori_type Kd_ori;

   typedef boost::array<double, 3>  _Kp_body_type;
  _Kp_body_type Kp_body;

   typedef boost::array<double, 3>  _Kp_cam_type;
  _Kp_cam_type Kp_cam;

   typedef boost::array<double, 3>  _Kp_clm_type;
  _Kp_clm_type Kp_clm;

   typedef boost::array<double, 3>  _Kp_foot_type;
  _Kp_foot_type Kp_foot;

   typedef boost::array<double, 3>  _Kp_joint_type;
  _Kp_joint_type Kp_joint;

   typedef boost::array<double, 3>  _Kp_ori_type;
  _Kp_ori_type Kp_ori;

   typedef boost::array<double, 3>  _Q_ang_type;
  _Q_ang_type Q_ang;

   typedef boost::array<double, 3>  _Q_ori_type;
  _Q_ori_type Q_ori;

   typedef boost::array<double, 3>  _Q_pos_type;
  _Q_pos_type Q_pos;

   typedef boost::array<double, 3>  _Q_vel_type;
  _Q_vel_type Q_vel;

   typedef boost::array<double, 3>  _RPC_H_phi0_type;
  _RPC_H_phi0_type RPC_H_phi0;

   typedef boost::array<double, 3>  _RPC_H_r_rot_type;
  _RPC_H_r_rot_type RPC_H_r_rot;

   typedef boost::array<double, 3>  _RPC_H_r_trans_type;
  _RPC_H_r_trans_type RPC_H_r_trans;

   typedef boost::array<double, 3>  _RPC_H_theta0_type;
  _RPC_H_theta0_type RPC_H_theta0;

   typedef boost::array<double, 3>  _RPC_Q_dp_type;
  _RPC_Q_dp_type RPC_Q_dp;

   typedef boost::array<double, 3>  _RPC_Q_dtheta_type;
  _RPC_Q_dtheta_type RPC_Q_dtheta;

   typedef boost::array<double, 3>  _RPC_Q_p_type;
  _RPC_Q_p_type RPC_Q_p;

   typedef boost::array<double, 3>  _RPC_Q_theta_type;
  _RPC_Q_theta_type RPC_Q_theta;

   typedef boost::array<double, 3>  _RPC_R_f_type;
  _RPC_R_f_type RPC_R_f;

   typedef boost::array<double, 3>  _RPC_R_r_type;
  _RPC_R_r_type RPC_R_r;

   typedef boost::array<double, 3>  _RPC_filter_type;
  _RPC_filter_type RPC_filter;

   typedef boost::array<double, 3>  _RPC_gravity_type;
  _RPC_gravity_type RPC_gravity;

   typedef boost::array<double, 3>  _RPC_inertia_type;
  _RPC_inertia_type RPC_inertia;

   typedef double _RPC_interface_type_type;
  _RPC_interface_type_type RPC_interface_type;

   typedef double _RPC_mass_type;
  _RPC_mass_type RPC_mass;

   typedef double _RPC_mu_type;
  _RPC_mu_type RPC_mu;

   typedef double _RPC_use_async_filt_type;
  _RPC_use_async_filt_type RPC_use_async_filt;

   typedef double _RPC_use_pred_comp_type;
  _RPC_use_pred_comp_type RPC_use_pred_comp;

   typedef double _RPC_visualize_pred_type;
  _RPC_visualize_pred_type RPC_visualize_pred;

   typedef double _R_control_type;
  _R_control_type R_control;

   typedef double _R_prev_type;
  _R_prev_type R_prev;

   typedef boost::array<double, 3>  _Swing_Kd_cartesian_type;
  _Swing_Kd_cartesian_type Swing_Kd_cartesian;

   typedef boost::array<double, 3>  _Swing_Kd_joint_type;
  _Swing_Kd_joint_type Swing_Kd_joint;

   typedef boost::array<double, 3>  _Swing_Kp_cartesian_type;
  _Swing_Kp_cartesian_type Swing_Kp_cartesian;

   typedef boost::array<double, 3>  _Swing_Kp_joint_type;
  _Swing_Kp_joint_type Swing_Kp_joint;

   typedef boost::array<double, 3>  _Swing_step_offset_type;
  _Swing_step_offset_type Swing_step_offset;

   typedef double _Swing_traj_height_type;
  _Swing_traj_height_type Swing_traj_height;

   typedef double _Swing_use_tau_ff_type;
  _Swing_use_tau_ff_type Swing_use_tau_ff;

   typedef double _acro_task_type;
  _acro_task_type acro_task;

   typedef boost::array<double, 3>  _des_dp_type;
  _des_dp_type des_dp;

   typedef boost::array<double, 3>  _des_dp_max_type;
  _des_dp_max_type des_dp_max;

   typedef boost::array<double, 3>  _des_dtheta_type;
  _des_dtheta_type des_dtheta;

   typedef boost::array<double, 3>  _des_dtheta_max_type;
  _des_dtheta_max_type des_dtheta_max;

   typedef boost::array<double, 3>  _des_p_type;
  _des_p_type des_p;

   typedef boost::array<double, 3>  _des_theta_type;
  _des_theta_type des_theta;

   typedef boost::array<double, 3>  _des_theta_max_type;
  _des_theta_max_type des_theta_max;

   typedef boost::array<double, 3>  _gait_disturbance_type;
  _gait_disturbance_type gait_disturbance;

   typedef double _gait_max_leg_angle_type;
  _gait_max_leg_angle_type gait_max_leg_angle;

   typedef double _gait_max_stance_time_type;
  _gait_max_stance_time_type gait_max_stance_time;

   typedef double _gait_min_stance_time_type;
  _gait_min_stance_time_type gait_min_stance_time;

   typedef double _gait_override_type;
  _gait_override_type gait_override;

   typedef double _gait_period_time_type;
  _gait_period_time_type gait_period_time;

   typedef boost::array<double, 3>  _gait_recovery_type;
  _gait_recovery_type gait_recovery;

   typedef double _gait_switching_phase_type;
  _gait_switching_phase_type gait_switching_phase;

   typedef double _gait_type_type;
  _gait_type_type gait_type;

   typedef double _stance_legs_type;
  _stance_legs_type stance_legs;





  typedef boost::shared_ptr< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> const> ConstPtr;

}; // struct quadruped_menu_data_lcmt_

typedef ::lcm_to_ros::quadruped_menu_data_lcmt_<std::allocator<void> > quadruped_menu_data_lcmt;

typedef boost::shared_ptr< ::lcm_to_ros::quadruped_menu_data_lcmt > quadruped_menu_data_lcmtPtr;
typedef boost::shared_ptr< ::lcm_to_ros::quadruped_menu_data_lcmt const> quadruped_menu_data_lcmtConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator1> & lhs, const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator2> & rhs)
{
  return lhs.cheater_mode == rhs.cheater_mode &&
    lhs.control_mode == rhs.control_mode &&
    lhs.use_wbc == rhs.use_wbc &&
    lhs.use_rc == rhs.use_rc &&
    lhs.display_heightmap == rhs.display_heightmap &&
    lhs.display_path_planning == rhs.display_path_planning &&
    lhs.display_potential_field == rhs.display_potential_field &&
    lhs.display_traverability == rhs.display_traverability &&
    lhs.Kd_body == rhs.Kd_body &&
    lhs.Kd_cam == rhs.Kd_cam &&
    lhs.Kd_clm == rhs.Kd_clm &&
    lhs.Kd_foot == rhs.Kd_foot &&
    lhs.Kd_joint == rhs.Kd_joint &&
    lhs.Kd_ori == rhs.Kd_ori &&
    lhs.Kp_body == rhs.Kp_body &&
    lhs.Kp_cam == rhs.Kp_cam &&
    lhs.Kp_clm == rhs.Kp_clm &&
    lhs.Kp_foot == rhs.Kp_foot &&
    lhs.Kp_joint == rhs.Kp_joint &&
    lhs.Kp_ori == rhs.Kp_ori &&
    lhs.Q_ang == rhs.Q_ang &&
    lhs.Q_ori == rhs.Q_ori &&
    lhs.Q_pos == rhs.Q_pos &&
    lhs.Q_vel == rhs.Q_vel &&
    lhs.RPC_H_phi0 == rhs.RPC_H_phi0 &&
    lhs.RPC_H_r_rot == rhs.RPC_H_r_rot &&
    lhs.RPC_H_r_trans == rhs.RPC_H_r_trans &&
    lhs.RPC_H_theta0 == rhs.RPC_H_theta0 &&
    lhs.RPC_Q_dp == rhs.RPC_Q_dp &&
    lhs.RPC_Q_dtheta == rhs.RPC_Q_dtheta &&
    lhs.RPC_Q_p == rhs.RPC_Q_p &&
    lhs.RPC_Q_theta == rhs.RPC_Q_theta &&
    lhs.RPC_R_f == rhs.RPC_R_f &&
    lhs.RPC_R_r == rhs.RPC_R_r &&
    lhs.RPC_filter == rhs.RPC_filter &&
    lhs.RPC_gravity == rhs.RPC_gravity &&
    lhs.RPC_inertia == rhs.RPC_inertia &&
    lhs.RPC_interface_type == rhs.RPC_interface_type &&
    lhs.RPC_mass == rhs.RPC_mass &&
    lhs.RPC_mu == rhs.RPC_mu &&
    lhs.RPC_use_async_filt == rhs.RPC_use_async_filt &&
    lhs.RPC_use_pred_comp == rhs.RPC_use_pred_comp &&
    lhs.RPC_visualize_pred == rhs.RPC_visualize_pred &&
    lhs.R_control == rhs.R_control &&
    lhs.R_prev == rhs.R_prev &&
    lhs.Swing_Kd_cartesian == rhs.Swing_Kd_cartesian &&
    lhs.Swing_Kd_joint == rhs.Swing_Kd_joint &&
    lhs.Swing_Kp_cartesian == rhs.Swing_Kp_cartesian &&
    lhs.Swing_Kp_joint == rhs.Swing_Kp_joint &&
    lhs.Swing_step_offset == rhs.Swing_step_offset &&
    lhs.Swing_traj_height == rhs.Swing_traj_height &&
    lhs.Swing_use_tau_ff == rhs.Swing_use_tau_ff &&
    lhs.acro_task == rhs.acro_task &&
    lhs.des_dp == rhs.des_dp &&
    lhs.des_dp_max == rhs.des_dp_max &&
    lhs.des_dtheta == rhs.des_dtheta &&
    lhs.des_dtheta_max == rhs.des_dtheta_max &&
    lhs.des_p == rhs.des_p &&
    lhs.des_theta == rhs.des_theta &&
    lhs.des_theta_max == rhs.des_theta_max &&
    lhs.gait_disturbance == rhs.gait_disturbance &&
    lhs.gait_max_leg_angle == rhs.gait_max_leg_angle &&
    lhs.gait_max_stance_time == rhs.gait_max_stance_time &&
    lhs.gait_min_stance_time == rhs.gait_min_stance_time &&
    lhs.gait_override == rhs.gait_override &&
    lhs.gait_period_time == rhs.gait_period_time &&
    lhs.gait_recovery == rhs.gait_recovery &&
    lhs.gait_switching_phase == rhs.gait_switching_phase &&
    lhs.gait_type == rhs.gait_type &&
    lhs.stance_legs == rhs.stance_legs;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator1> & lhs, const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace lcm_to_ros

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9ab9aae0547b79b2b0e50af1fdc2a2dc";
  }

  static const char* value(const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9ab9aae0547b79b2ULL;
  static const uint64_t static_value2 = 0xb0e50af1fdc2a2dcULL;
};

template<class ContainerAllocator>
struct DataType< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
{
  static const char* value()
  {
    return "lcm_to_ros/quadruped_menu_data_lcmt";
  }

  static const char* value(const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#######################################################################\n"
"# This message was automatically generated by the lcm_to_ros package\n"
"# https://github.com/nrjl/lcm_to_ros, nicholas.lawrance@oregonstate.edu\n"
"#######################################################################\n"
"#\n"
"# Source message:    .msg\n"
"# Creation:          Fri Apr 16 18:27:01 2021\n"
"#\n"
"#######################################################################\n"
"bool                cheater_mode\n"
"int64               control_mode\n"
"                    \n"
"bool                use_wbc\n"
"bool                use_rc\n"
"                    \n"
"bool                display_heightmap\n"
"bool                display_path_planning\n"
"bool                display_potential_field\n"
"bool                display_traverability\n"
"                    \n"
"float64[3]          Kd_body\n"
"float64[3]          Kd_cam\n"
"float64[3]          Kd_clm\n"
"float64[3]          Kd_foot\n"
"float64[3]          Kd_joint\n"
"float64[3]          Kd_ori\n"
"float64[3]          Kp_body\n"
"float64[3]          Kp_cam\n"
"float64[3]          Kp_clm\n"
"float64[3]          Kp_foot\n"
"float64[3]          Kp_joint\n"
"float64[3]          Kp_ori\n"
"float64[3]          Q_ang\n"
"float64[3]          Q_ori\n"
"float64[3]          Q_pos\n"
"float64[3]          Q_vel\n"
"float64[3]          RPC_H_phi0\n"
"float64[3]          RPC_H_r_rot\n"
"float64[3]          RPC_H_r_trans\n"
"float64[3]          RPC_H_theta0\n"
"float64[3]          RPC_Q_dp\n"
"float64[3]          RPC_Q_dtheta\n"
"float64[3]          RPC_Q_p\n"
"float64[3]          RPC_Q_theta\n"
"float64[3]          RPC_R_f\n"
"float64[3]          RPC_R_r\n"
"float64[3]          RPC_filter\n"
"float64[3]          RPC_gravity\n"
"float64[3]          RPC_inertia\n"
"float64             RPC_interface_type\n"
"float64             RPC_mass\n"
"float64             RPC_mu\n"
"float64             RPC_use_async_filt\n"
"float64             RPC_use_pred_comp\n"
"float64             RPC_visualize_pred\n"
"float64             R_control\n"
"float64             R_prev\n"
"float64[3]          Swing_Kd_cartesian\n"
"float64[3]          Swing_Kd_joint\n"
"float64[3]          Swing_Kp_cartesian\n"
"float64[3]          Swing_Kp_joint\n"
"float64[3]          Swing_step_offset\n"
"float64             Swing_traj_height\n"
"float64             Swing_use_tau_ff\n"
"float64             acro_task\n"
"float64[3]          des_dp\n"
"float64[3]          des_dp_max\n"
"float64[3]          des_dtheta\n"
"float64[3]          des_dtheta_max\n"
"float64[3]          des_p\n"
"float64[3]          des_theta\n"
"float64[3]          des_theta_max\n"
"float64[3]          gait_disturbance\n"
"float64             gait_max_leg_angle\n"
"float64             gait_max_stance_time\n"
"float64             gait_min_stance_time\n"
"float64             gait_override\n"
"float64             gait_period_time\n"
"float64[3]          gait_recovery\n"
"float64             gait_switching_phase\n"
"float64             gait_type\n"
"float64             stance_legs\n"
;
  }

  static const char* value(const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.cheater_mode);
      stream.next(m.control_mode);
      stream.next(m.use_wbc);
      stream.next(m.use_rc);
      stream.next(m.display_heightmap);
      stream.next(m.display_path_planning);
      stream.next(m.display_potential_field);
      stream.next(m.display_traverability);
      stream.next(m.Kd_body);
      stream.next(m.Kd_cam);
      stream.next(m.Kd_clm);
      stream.next(m.Kd_foot);
      stream.next(m.Kd_joint);
      stream.next(m.Kd_ori);
      stream.next(m.Kp_body);
      stream.next(m.Kp_cam);
      stream.next(m.Kp_clm);
      stream.next(m.Kp_foot);
      stream.next(m.Kp_joint);
      stream.next(m.Kp_ori);
      stream.next(m.Q_ang);
      stream.next(m.Q_ori);
      stream.next(m.Q_pos);
      stream.next(m.Q_vel);
      stream.next(m.RPC_H_phi0);
      stream.next(m.RPC_H_r_rot);
      stream.next(m.RPC_H_r_trans);
      stream.next(m.RPC_H_theta0);
      stream.next(m.RPC_Q_dp);
      stream.next(m.RPC_Q_dtheta);
      stream.next(m.RPC_Q_p);
      stream.next(m.RPC_Q_theta);
      stream.next(m.RPC_R_f);
      stream.next(m.RPC_R_r);
      stream.next(m.RPC_filter);
      stream.next(m.RPC_gravity);
      stream.next(m.RPC_inertia);
      stream.next(m.RPC_interface_type);
      stream.next(m.RPC_mass);
      stream.next(m.RPC_mu);
      stream.next(m.RPC_use_async_filt);
      stream.next(m.RPC_use_pred_comp);
      stream.next(m.RPC_visualize_pred);
      stream.next(m.R_control);
      stream.next(m.R_prev);
      stream.next(m.Swing_Kd_cartesian);
      stream.next(m.Swing_Kd_joint);
      stream.next(m.Swing_Kp_cartesian);
      stream.next(m.Swing_Kp_joint);
      stream.next(m.Swing_step_offset);
      stream.next(m.Swing_traj_height);
      stream.next(m.Swing_use_tau_ff);
      stream.next(m.acro_task);
      stream.next(m.des_dp);
      stream.next(m.des_dp_max);
      stream.next(m.des_dtheta);
      stream.next(m.des_dtheta_max);
      stream.next(m.des_p);
      stream.next(m.des_theta);
      stream.next(m.des_theta_max);
      stream.next(m.gait_disturbance);
      stream.next(m.gait_max_leg_angle);
      stream.next(m.gait_max_stance_time);
      stream.next(m.gait_min_stance_time);
      stream.next(m.gait_override);
      stream.next(m.gait_period_time);
      stream.next(m.gait_recovery);
      stream.next(m.gait_switching_phase);
      stream.next(m.gait_type);
      stream.next(m.stance_legs);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct quadruped_menu_data_lcmt_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::lcm_to_ros::quadruped_menu_data_lcmt_<ContainerAllocator>& v)
  {
    s << indent << "cheater_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cheater_mode);
    s << indent << "control_mode: ";
    Printer<int64_t>::stream(s, indent + "  ", v.control_mode);
    s << indent << "use_wbc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.use_wbc);
    s << indent << "use_rc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.use_rc);
    s << indent << "display_heightmap: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.display_heightmap);
    s << indent << "display_path_planning: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.display_path_planning);
    s << indent << "display_potential_field: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.display_potential_field);
    s << indent << "display_traverability: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.display_traverability);
    s << indent << "Kd_body[]" << std::endl;
    for (size_t i = 0; i < v.Kd_body.size(); ++i)
    {
      s << indent << "  Kd_body[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kd_body[i]);
    }
    s << indent << "Kd_cam[]" << std::endl;
    for (size_t i = 0; i < v.Kd_cam.size(); ++i)
    {
      s << indent << "  Kd_cam[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kd_cam[i]);
    }
    s << indent << "Kd_clm[]" << std::endl;
    for (size_t i = 0; i < v.Kd_clm.size(); ++i)
    {
      s << indent << "  Kd_clm[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kd_clm[i]);
    }
    s << indent << "Kd_foot[]" << std::endl;
    for (size_t i = 0; i < v.Kd_foot.size(); ++i)
    {
      s << indent << "  Kd_foot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kd_foot[i]);
    }
    s << indent << "Kd_joint[]" << std::endl;
    for (size_t i = 0; i < v.Kd_joint.size(); ++i)
    {
      s << indent << "  Kd_joint[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kd_joint[i]);
    }
    s << indent << "Kd_ori[]" << std::endl;
    for (size_t i = 0; i < v.Kd_ori.size(); ++i)
    {
      s << indent << "  Kd_ori[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kd_ori[i]);
    }
    s << indent << "Kp_body[]" << std::endl;
    for (size_t i = 0; i < v.Kp_body.size(); ++i)
    {
      s << indent << "  Kp_body[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kp_body[i]);
    }
    s << indent << "Kp_cam[]" << std::endl;
    for (size_t i = 0; i < v.Kp_cam.size(); ++i)
    {
      s << indent << "  Kp_cam[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kp_cam[i]);
    }
    s << indent << "Kp_clm[]" << std::endl;
    for (size_t i = 0; i < v.Kp_clm.size(); ++i)
    {
      s << indent << "  Kp_clm[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kp_clm[i]);
    }
    s << indent << "Kp_foot[]" << std::endl;
    for (size_t i = 0; i < v.Kp_foot.size(); ++i)
    {
      s << indent << "  Kp_foot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kp_foot[i]);
    }
    s << indent << "Kp_joint[]" << std::endl;
    for (size_t i = 0; i < v.Kp_joint.size(); ++i)
    {
      s << indent << "  Kp_joint[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kp_joint[i]);
    }
    s << indent << "Kp_ori[]" << std::endl;
    for (size_t i = 0; i < v.Kp_ori.size(); ++i)
    {
      s << indent << "  Kp_ori[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Kp_ori[i]);
    }
    s << indent << "Q_ang[]" << std::endl;
    for (size_t i = 0; i < v.Q_ang.size(); ++i)
    {
      s << indent << "  Q_ang[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Q_ang[i]);
    }
    s << indent << "Q_ori[]" << std::endl;
    for (size_t i = 0; i < v.Q_ori.size(); ++i)
    {
      s << indent << "  Q_ori[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Q_ori[i]);
    }
    s << indent << "Q_pos[]" << std::endl;
    for (size_t i = 0; i < v.Q_pos.size(); ++i)
    {
      s << indent << "  Q_pos[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Q_pos[i]);
    }
    s << indent << "Q_vel[]" << std::endl;
    for (size_t i = 0; i < v.Q_vel.size(); ++i)
    {
      s << indent << "  Q_vel[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Q_vel[i]);
    }
    s << indent << "RPC_H_phi0[]" << std::endl;
    for (size_t i = 0; i < v.RPC_H_phi0.size(); ++i)
    {
      s << indent << "  RPC_H_phi0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_H_phi0[i]);
    }
    s << indent << "RPC_H_r_rot[]" << std::endl;
    for (size_t i = 0; i < v.RPC_H_r_rot.size(); ++i)
    {
      s << indent << "  RPC_H_r_rot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_H_r_rot[i]);
    }
    s << indent << "RPC_H_r_trans[]" << std::endl;
    for (size_t i = 0; i < v.RPC_H_r_trans.size(); ++i)
    {
      s << indent << "  RPC_H_r_trans[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_H_r_trans[i]);
    }
    s << indent << "RPC_H_theta0[]" << std::endl;
    for (size_t i = 0; i < v.RPC_H_theta0.size(); ++i)
    {
      s << indent << "  RPC_H_theta0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_H_theta0[i]);
    }
    s << indent << "RPC_Q_dp[]" << std::endl;
    for (size_t i = 0; i < v.RPC_Q_dp.size(); ++i)
    {
      s << indent << "  RPC_Q_dp[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_Q_dp[i]);
    }
    s << indent << "RPC_Q_dtheta[]" << std::endl;
    for (size_t i = 0; i < v.RPC_Q_dtheta.size(); ++i)
    {
      s << indent << "  RPC_Q_dtheta[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_Q_dtheta[i]);
    }
    s << indent << "RPC_Q_p[]" << std::endl;
    for (size_t i = 0; i < v.RPC_Q_p.size(); ++i)
    {
      s << indent << "  RPC_Q_p[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_Q_p[i]);
    }
    s << indent << "RPC_Q_theta[]" << std::endl;
    for (size_t i = 0; i < v.RPC_Q_theta.size(); ++i)
    {
      s << indent << "  RPC_Q_theta[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_Q_theta[i]);
    }
    s << indent << "RPC_R_f[]" << std::endl;
    for (size_t i = 0; i < v.RPC_R_f.size(); ++i)
    {
      s << indent << "  RPC_R_f[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_R_f[i]);
    }
    s << indent << "RPC_R_r[]" << std::endl;
    for (size_t i = 0; i < v.RPC_R_r.size(); ++i)
    {
      s << indent << "  RPC_R_r[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_R_r[i]);
    }
    s << indent << "RPC_filter[]" << std::endl;
    for (size_t i = 0; i < v.RPC_filter.size(); ++i)
    {
      s << indent << "  RPC_filter[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_filter[i]);
    }
    s << indent << "RPC_gravity[]" << std::endl;
    for (size_t i = 0; i < v.RPC_gravity.size(); ++i)
    {
      s << indent << "  RPC_gravity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_gravity[i]);
    }
    s << indent << "RPC_inertia[]" << std::endl;
    for (size_t i = 0; i < v.RPC_inertia.size(); ++i)
    {
      s << indent << "  RPC_inertia[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.RPC_inertia[i]);
    }
    s << indent << "RPC_interface_type: ";
    Printer<double>::stream(s, indent + "  ", v.RPC_interface_type);
    s << indent << "RPC_mass: ";
    Printer<double>::stream(s, indent + "  ", v.RPC_mass);
    s << indent << "RPC_mu: ";
    Printer<double>::stream(s, indent + "  ", v.RPC_mu);
    s << indent << "RPC_use_async_filt: ";
    Printer<double>::stream(s, indent + "  ", v.RPC_use_async_filt);
    s << indent << "RPC_use_pred_comp: ";
    Printer<double>::stream(s, indent + "  ", v.RPC_use_pred_comp);
    s << indent << "RPC_visualize_pred: ";
    Printer<double>::stream(s, indent + "  ", v.RPC_visualize_pred);
    s << indent << "R_control: ";
    Printer<double>::stream(s, indent + "  ", v.R_control);
    s << indent << "R_prev: ";
    Printer<double>::stream(s, indent + "  ", v.R_prev);
    s << indent << "Swing_Kd_cartesian[]" << std::endl;
    for (size_t i = 0; i < v.Swing_Kd_cartesian.size(); ++i)
    {
      s << indent << "  Swing_Kd_cartesian[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Swing_Kd_cartesian[i]);
    }
    s << indent << "Swing_Kd_joint[]" << std::endl;
    for (size_t i = 0; i < v.Swing_Kd_joint.size(); ++i)
    {
      s << indent << "  Swing_Kd_joint[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Swing_Kd_joint[i]);
    }
    s << indent << "Swing_Kp_cartesian[]" << std::endl;
    for (size_t i = 0; i < v.Swing_Kp_cartesian.size(); ++i)
    {
      s << indent << "  Swing_Kp_cartesian[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Swing_Kp_cartesian[i]);
    }
    s << indent << "Swing_Kp_joint[]" << std::endl;
    for (size_t i = 0; i < v.Swing_Kp_joint.size(); ++i)
    {
      s << indent << "  Swing_Kp_joint[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Swing_Kp_joint[i]);
    }
    s << indent << "Swing_step_offset[]" << std::endl;
    for (size_t i = 0; i < v.Swing_step_offset.size(); ++i)
    {
      s << indent << "  Swing_step_offset[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.Swing_step_offset[i]);
    }
    s << indent << "Swing_traj_height: ";
    Printer<double>::stream(s, indent + "  ", v.Swing_traj_height);
    s << indent << "Swing_use_tau_ff: ";
    Printer<double>::stream(s, indent + "  ", v.Swing_use_tau_ff);
    s << indent << "acro_task: ";
    Printer<double>::stream(s, indent + "  ", v.acro_task);
    s << indent << "des_dp[]" << std::endl;
    for (size_t i = 0; i < v.des_dp.size(); ++i)
    {
      s << indent << "  des_dp[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.des_dp[i]);
    }
    s << indent << "des_dp_max[]" << std::endl;
    for (size_t i = 0; i < v.des_dp_max.size(); ++i)
    {
      s << indent << "  des_dp_max[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.des_dp_max[i]);
    }
    s << indent << "des_dtheta[]" << std::endl;
    for (size_t i = 0; i < v.des_dtheta.size(); ++i)
    {
      s << indent << "  des_dtheta[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.des_dtheta[i]);
    }
    s << indent << "des_dtheta_max[]" << std::endl;
    for (size_t i = 0; i < v.des_dtheta_max.size(); ++i)
    {
      s << indent << "  des_dtheta_max[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.des_dtheta_max[i]);
    }
    s << indent << "des_p[]" << std::endl;
    for (size_t i = 0; i < v.des_p.size(); ++i)
    {
      s << indent << "  des_p[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.des_p[i]);
    }
    s << indent << "des_theta[]" << std::endl;
    for (size_t i = 0; i < v.des_theta.size(); ++i)
    {
      s << indent << "  des_theta[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.des_theta[i]);
    }
    s << indent << "des_theta_max[]" << std::endl;
    for (size_t i = 0; i < v.des_theta_max.size(); ++i)
    {
      s << indent << "  des_theta_max[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.des_theta_max[i]);
    }
    s << indent << "gait_disturbance[]" << std::endl;
    for (size_t i = 0; i < v.gait_disturbance.size(); ++i)
    {
      s << indent << "  gait_disturbance[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.gait_disturbance[i]);
    }
    s << indent << "gait_max_leg_angle: ";
    Printer<double>::stream(s, indent + "  ", v.gait_max_leg_angle);
    s << indent << "gait_max_stance_time: ";
    Printer<double>::stream(s, indent + "  ", v.gait_max_stance_time);
    s << indent << "gait_min_stance_time: ";
    Printer<double>::stream(s, indent + "  ", v.gait_min_stance_time);
    s << indent << "gait_override: ";
    Printer<double>::stream(s, indent + "  ", v.gait_override);
    s << indent << "gait_period_time: ";
    Printer<double>::stream(s, indent + "  ", v.gait_period_time);
    s << indent << "gait_recovery[]" << std::endl;
    for (size_t i = 0; i < v.gait_recovery.size(); ++i)
    {
      s << indent << "  gait_recovery[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.gait_recovery[i]);
    }
    s << indent << "gait_switching_phase: ";
    Printer<double>::stream(s, indent + "  ", v.gait_switching_phase);
    s << indent << "gait_type: ";
    Printer<double>::stream(s, indent + "  ", v.gait_type);
    s << indent << "stance_legs: ";
    Printer<double>::stream(s, indent + "  ", v.stance_legs);
  }
};

} // namespace message_operations
} // namespace ros

#endif // LCM_TO_ROS_MESSAGE_QUADRUPED_MENU_DATA_LCMT_H
